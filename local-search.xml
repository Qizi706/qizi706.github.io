<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6.s081 Lab2:system calls 实现</title>
    <link href="/2026/01/02/6-s081-lab2/"/>
    <url>/2026/01/02/6-s081-lab2/</url>
    
    <content type="html"><![CDATA[<h2 id="6-s081-Lab2-system-calls-实现"><a href="#6-s081-Lab2-system-calls-实现" class="headerlink" title="6.s081 Lab2:system calls 实现"></a>6.s081 Lab2:system calls 实现</h2><p>Lab2 实现了两个系统调用层面的功能，在开始写代码之前要求先读完 <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6-book</a> 的 Chapter 2 and Sections 4.3 and 4.4 of Chapter 4，以及相关的源文件，花了两天不到的时间。</p><p>做完这次实验可以深入理解 OS 的用户态、内核态的隔离，以及系统调用。</p><span id="more"></span><p>实现了两个简单的系统调用：</p><h3 id="0-前言：系统调用的过程"><a href="#0-前言：系统调用的过程" class="headerlink" title="0. 前言：系统调用的过程"></a>0. 前言：系统调用的过程</h3><p>这是一个从 <strong>用户态（User Space）</strong> 跨越到 <strong>内核态（Kernel Space）</strong> 最后返回用户程序继续执行的过程，流程非常严谨，主要分为以下 5 个关键阶段:</p><h4 id="第一阶段：用户态准备（User-Space）"><a href="#第一阶段：用户态准备（User-Space）" class="headerlink" title="第一阶段：用户态准备（User Space）"></a>第一阶段：用户态准备（User Space）</h4><ol><li><p><strong>C 函数调用</strong>：在用户态执行会引发系统调用的指令，比如 <code>trace(mask)</code> 或 <code>sysinfo(&amp;info)</code> ，编译器会去寻找它的定义。</p></li><li><p><strong>存根（Stub）</strong> <code>usys.S</code>：修改的 <code>usys.pl</code> 会生成 <code>usys.S</code> 汇编代码，这是真正的入口：</p></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;<br><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">entry</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> <span class="hljs-variable">$name</span> = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;.global <span class="hljs-variable">$name</span>\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>:\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; li a7, SYS_<span class="hljs-subst">$&#123;name&#125;</span>\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ecall\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ret\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>a7</code> <strong>寄存器</strong>：存储系统调用号，内核只会看这个寄存器来知道你想要干什么。</li><li><code>ecall</code> <strong>指令</strong>：这是 CPU 的硬件指令，一旦执行，CPU 权限就会从 User Mode 提升到 Supervisor Mode。</li></ul><h4 id="第二阶段：跨越边界（The-Trap）"><a href="#第二阶段：跨越边界（The-Trap）" class="headerlink" title="第二阶段：跨越边界（The Trap）"></a>第二阶段：跨越边界（The Trap）</h4><p><code>ecall</code> 执行的瞬间，硬件接管了控制权，发生了以下改变：</p><p><img src="/asserts/6-s081-lab2_assert/ecall.png" alt="xv-book-ecall"></p><ol><li><p><strong>跳转</strong>：CPU 读取 <code>stvec</code> 寄存器（里面存着内核入口位置），跳转到 <code>trampoline.S</code> 中的 <code>uservec</code> 代码段。</p></li><li><p><strong>权限提升</strong>：现在的代码实在 Supervisor Mode 下运行的。</p></li></ol><h4 id="第三阶段：蹦床机制（Trampoline）"><a href="#第三阶段：蹦床机制（Trampoline）" class="headerlink" title="第三阶段：蹦床机制（Trampoline）"></a>第三阶段：蹦床机制（Trampoline）</h4><p>此时内存页表（Page Table）还是用户进程的页表，内核代码大部分是看不见的。</p><ol><li><p><strong>保存现场（<code>uservec</code>）</strong>：在 <code>trampoline.S</code> 中，代码把所有用户寄存器中的内容（a0, a1, sp, pc 等）都保存到 <code>p-&gt;trapframe</code> 结构体中，以便之后还可以返回用户程序继续运行。</p></li><li><p><strong>切换页表</strong>：代码修改 <code>satp</code> 寄存器，从用户页表切换到内核页表，此时内核才能真正访问内核内存空间。</p></li><li><p><strong>跳转到 C 代码</strong>：最后跳转到 <code>trap.c</code> 中的 <code>usertrap()</code> 函数。</p></li></ol><h4 id="第四阶段：分发与执行（Kernel-Space）"><a href="#第四阶段：分发与执行（Kernel-Space）" class="headerlink" title="第四阶段：分发与执行（Kernel Space）"></a>第四阶段：分发与执行（Kernel Space）</h4><p>现在安全地在内核 C 环境中了。</p><ol><li><p><code>usertrap()</code>：它主要检查发生异常的原因（<code>scause</code> 寄存器），根据寄存器中的 8 判断是系统调用引发异常。</p></li><li><p><code>syscall()</code>：从保存的上下文（<code>trapframe-&gt;a7</code>）中取出中断号。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">num = p-&gt;trapframe-&gt;a7;<br><span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>  p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>执行系统调用处理函数：这里设计我们实现的系统调用函数以及 xv6 原本已经实现好的系统调用函数，执行这些函数。</li></ol><h4 id="第五阶段：返回（Return）"><a href="#第五阶段：返回（Return）" class="headerlink" title="第五阶段：返回（Return）"></a>第五阶段：返回（Return）</h4><p>任务完成，要返回用户程序继续执行。</p><ol><li><p><strong>设置返回值</strong>：刚刚的 <code>syscall()</code> 中已经将系统调用函数的返回值存进了 <code>p-&gt;trapframe-&gt;a0</code> 中，在 RISC—V 中 a0 寄存器用于存放返回值。</p></li><li><p><code>usertrapret()</code>：关中断，准备返回用户态，设置 <code>stvec</code> 指向 <code>trampoline</code> 以便下次系统调用能找回来。</p></li><li><p><code>userret</code>：再次切换页表（内核页表-&gt;用户页表）。把 <code>trapframe</code> 中保存的寄存器值全部恢复到 CPU 中。</p></li><li><p><code>sret</code>：这是 <code>ecall</code> 的逆操作，可以从 Supervisor Mode 返回 User Mode，PC 中的值恢复到刚刚产生异常时应该执行的下一行代码（这里会根据异常种类的不同而指向原本引发中断的代码或原本引发中段的下一行代码。与操作系统理论课中学过的内容一致）。</p></li></ol><h3 id="1-System-call-tracing-moderate"><a href="#1-System-call-tracing-moderate" class="headerlink" title="1. System call tracing (moderate)"></a>1. System call tracing (<u>moderate</u>)</h3><p>实现一个根据掩码（mask）对系统调用进行追踪的系统调用，使用 <code>trace</code> 指令后会发出一个系统调用，例如 <code>trace(1 &lt;&lt; SYS_fork)</code> 就可以对 <code>fork</code> 这个系统调用进行追踪，返回所追踪的系统调用的 pid、系统调用名以及返回值（如下图），对后续的 debug 过程有一定帮助。</p><p><img src="/asserts/6-s081-lab2_assert/trace.png" alt="trace"></p><p>根据上面提到的系统调用的过程，如果想要为操作系统添加一个系统调用，需要进行以下步骤：</p><h4 id="添加系统调用存根（Stub）"><a href="#添加系统调用存根（Stub）" class="headerlink" title="添加系统调用存根（Stub）"></a>添加系统调用存根（Stub）</h4><p>修改 <code>user/usys.pl</code></p><figure class="highlight perl"><figcaption><span>user/usys.pl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># ...</span><br>entry(<span class="hljs-string">&quot;trace&quot;</span>);<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h4 id="添加函数签名"><a href="#添加函数签名" class="headerlink" title="添加函数签名"></a>添加函数签名</h4><p>我们会在用户程序中使用系统调用函数，因此要修改 <code>user/user.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h4 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h4><p>在 <code>kernel/syscall.h</code> 中添加一个系统调用号的宏定义:</p><p>系统调用号唯一，这里要不同于之前的系统调用号。</p><figure class="highlight c"><figcaption><span>kernel/syscall.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_trace  22</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>修改 <code>kernel/syscall.c</code> 中的一些静态变量:</p><ul><li>申明全局系统调用函数:</li></ul><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><ul><li>添加 <code>syscalls</code>，目的是通过系统调用好能够找到对应的系统调用：</li></ul><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br><span class="hljs-comment">// ...</span><br>[SYS_trace]   = sys_trace,<br><span class="hljs-comment">// ...</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>新增一个 <code>syscall_names</code> 静态数组用于将系统调用号映射为相应系统调用名:</li></ul><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *syscall_names[] = &#123;<br>  [SYS_fork]    = <span class="hljs-string">&quot;fork&quot;</span>,<br>  [SYS_exit]    = <span class="hljs-string">&quot;exit&quot;</span>,<br>  [SYS_wait]    = <span class="hljs-string">&quot;wait&quot;</span>,<br>  [SYS_pipe]    = <span class="hljs-string">&quot;pipe&quot;</span>,<br>  [SYS_read]    = <span class="hljs-string">&quot;read&quot;</span>,<br>  [SYS_kill]    = <span class="hljs-string">&quot;kill&quot;</span>,<br>  [SYS_exec]    = <span class="hljs-string">&quot;exec&quot;</span>,<br>  [SYS_fstat]   = <span class="hljs-string">&quot;fstat&quot;</span>,<br>  [SYS_chdir]   = <span class="hljs-string">&quot;chdir&quot;</span>,<br>  [SYS_dup]     = <span class="hljs-string">&quot;dup&quot;</span>,<br>  [SYS_getpid]  = <span class="hljs-string">&quot;getpid&quot;</span>,<br>  [SYS_sbrk]    = <span class="hljs-string">&quot;sbrk&quot;</span>,<br>  [SYS_sleep]   = <span class="hljs-string">&quot;sleep&quot;</span>,<br>  [SYS_uptime]  = <span class="hljs-string">&quot;uptime&quot;</span>,<br>  [SYS_open]    = <span class="hljs-string">&quot;open&quot;</span>,<br>  [SYS_write]   = <span class="hljs-string">&quot;write&quot;</span>,<br>  [SYS_mknod]   = <span class="hljs-string">&quot;mknod&quot;</span>,<br>  [SYS_unlink]  = <span class="hljs-string">&quot;unlink&quot;</span>,<br>  [SYS_link]    = <span class="hljs-string">&quot;link&quot;</span>,<br>  [SYS_mkdir]   = <span class="hljs-string">&quot;mkdir&quot;</span>,<br>  [SYS_close]   = <span class="hljs-string">&quot;close&quot;</span>,<br>  [SYS_trace]   = <span class="hljs-string">&quot;trace&quot;</span>,<br>  [SYS_sysinfo] = <span class="hljs-string">&quot;sysinfo&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="实现-trace-系统调用"><a href="#实现-trace-系统调用" class="headerlink" title="实现 trace 系统调用"></a>实现 <code>trace</code> 系统调用</h4><p>首先添加实现 <code>trace</code> 必要的额外变量：</p><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">int</span> trace_mask;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个变量用于在进程中存储 <code>trace</code> 的掩码。</p><p>系统调用的实现都在 <code>kernel/sysproc.c</code> 中，因此在这个文件中添加一个函数 <code>sys_trace</code>，与上面的 <code>syscalls</code> 中添加的函数名一致。</p><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> mask;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  myproc()-&gt;trace_mask = mask;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>argint</code> 函数用于获取引发系统调用的函数中的参数，这里为 <code>trace</code> 所需要的掩码，获取到后将其存放到当前进程的 <code>proc</code> 状态结构体中。</p><p>这里这个系统调用完成的事情已经做完了，但是想要能够监测系统调用，还需要在 <code>syscall()</code> 函数中添加几行代码将检测到的内容输出:</p><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br><br>    <span class="hljs-keyword">if</span> ((p-&gt;trace_mask &gt;&gt; num) &amp; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,<br>             p-&gt;pid,<br>             syscall_names[p-&gt;trapframe-&gt;a7],<br>             p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Sysinfo-moderate"><a href="#2-Sysinfo-moderate" class="headerlink" title="2. Sysinfo (moderate)"></a>2. Sysinfo (<u>moderate</u>)</h3><p>这个系统调用的功能更是收集这个正在运行的系统的信息。<code>sysinfo</code> 接收一个指向 <code>struct sysinfo</code> 的指针作为参数，内核应该填充这个结构体的各个字段：</p><ul><li><code>freemem</code> ：内存空闲的字节数</li><li><code>nproc</code>：<code>state</code> 不为 UNUSED 的进程数（也就是正在运行的进程数）</li></ul><p>基本系统调用需要添加的内容与上一个任务一样，除此之外这个实现中涉及内核态向用户态传递内核的一些数据，这就是这个任务的唯一难题了。</p><p>先观察一下 <code>struct sysinfo</code>：</p><figure class="highlight c"><figcaption><span>kernel/sysinfo.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> &#123;</span><br>  uint64 freemem;   <span class="hljs-comment">// amount of free memory (bytes)</span><br>  uint64 nproc;     <span class="hljs-comment">// number of process</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>主要就是两个 uint64 字段，因此只要获取到这两个字段的内容就好了。</p><p>题目给出的提示中说参考 sys_fstat() 函数以及 filestat() 函数，就是告诉我们如何从内核中向用户空间中写入数据。</p><p>这两段代码演示了两个重要的函数： argaddr 以及 copyout。这两个函数在 xv6-book 中已有介绍：</p><ul><li>argaddr：与 argint&#x2F;argfd 类似，获取第 n 个系统调用函数作为（地址&#x2F;整数&#x2F;文件描述符）。</li></ul><blockquote><p>The kernel functions argint, argaddr, and argfd retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a file descriptor.</p></blockquote><ul><li>copyout：从内核空间中拷贝数据到用户提供的地址（这里的地址是用户页表下的虚拟地址，因此可以防止攻击其他的用户进程）。</li></ul><blockquote><p>copyinstr (kernel&#x2F;vm.c:403) copies up to max bytes to dst from virtual address srcva in the user page table pagetable. … A similar function, copyout, copies data from the kernel to a user-supplied address.</p></blockquote><p>了解了上面的内容后 sys_sysinfo 的实现只需要获取到<strong>空闲内存</strong>以及<strong>进程数</strong>了，还需要写两个函数： kcollect_freemem 以及 collect_nproc。</p><figure class="highlight c"><figcaption><span>kernel kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">kcollect_freemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  uint64 n = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br><br>  <span class="hljs-keyword">while</span> (r) &#123;<br>    n++;<br>    r = r-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">return</span> n * PGSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>kcollect_freemem 函数访问 kmem 结构体，其中有两个内容：一个结构体的锁和空闲物理内存链表的表头指针。</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br></code></pre></td></tr></table></figure><p>这里的自旋锁不做过多解释，后面会有 lab 详细涉及，这里只需要获取和释放就行了。</p><p>freelist 是利用了页表的前 8 个字节作为指针指向下一个页表的起始地址，因此只需要不断遍历链表就可以获取空闲页表的数量，在这个基础上乘以页表大小就可以获取到 freemem。因此 kcollect_freemem 函数实现如下：</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">kcollect_freemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  uint64 n = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br><br>  <span class="hljs-keyword">while</span> (r) &#123;<br>    n++;<br>    r = r-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">return</span> n * PGSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来实现 collect_nproc 函数只需要遍历一下 kernel&#x2F;proc.c 中的 proc 数组，统计有多少个 p-&gt;state 不为 UNUSED 即可：</p><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">collect_nproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  uint64 n = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;state != UNUSED)<br>      n++;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后实现一下 sys_sysinfo 系统调用函数，使用 argaddr 和 copyout 将以上函数获取到的信息写入用户空间中：</p><figure class="highlight c"><figcaption><span>kernel.sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  uint64 addr;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>) <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  info.freemem = kcollect_freemem();<br>  info.nproc = collect_nproc();<br><br>  <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;info, <span class="hljs-keyword">sizeof</span>(info)) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是 Lab2 的所有内容，完成这个需要理解也会加深理解对操作系统的系统调用相关的知识。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>MIT courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
      <tag>Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081 Lab1:Xv6 and Unix utilities 实现</title>
    <link href="/2025/12/30/6-s081-lab1/"/>
    <url>/2025/12/30/6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="6-s081-Lab1-Xv6-and-Unix-utilities-实现"><a href="#6-s081-Lab1-Xv6-and-Unix-utilities-实现" class="headerlink" title="6.s081 Lab1:Xv6 and Unix utilities 实现"></a>6.s081 Lab1:Xv6 and Unix utilities 实现</h2><p>记录一下写 6.s081 Lab1 的过程，还有在这个实验中学到的新的知识。</p><p>这一次实验的内容为 Xv6 and Unix Utilities，实现一些基本 Unix 工具，通过这个过程了解 xv6 系统的结构，以及是如何运行的，建立对其的基本认识。</p><span id="more"></span><p>主要实现以下的几个功能:</p><h3 id="1-sleep-easy"><a href="#1-sleep-easy" class="headerlink" title="1.sleep (easy)"></a>1.sleep (<u>easy</u>)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">if</span> (sleep(ticks) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;sleep: system call failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要考察对一些基本系统调用的使用，这里使用了 sleep 系统调用，传入一个参数 tick 作为 sleep 的时间，fprintf 中的第一个参数2表示在 qemu 的终端中输出，如果系统调用错误就 exit 1，否则程序将在 sleep 后退出。</p><h3 id="2-pingpong-easy"><a href="#2-pingpong-easy" class="headerlink" title="2.pingpong (easy)"></a>2.pingpong (<u>easy</u>)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>  <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">char</span> buf;<br>  <span class="hljs-keyword">if</span> (pipe(p1) &lt; <span class="hljs-number">0</span> || pipe(p2) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;pipe() failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-type">int</span> pid = fork();<br><br>  <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;fork: system call failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>    close(p1[<span class="hljs-number">1</span>]);<br>    close(p2[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">if</span> (read(p1[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read: system call failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br><br>    <span class="hljs-keyword">if</span> (write(p2[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write: system call failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    close(p1[<span class="hljs-number">0</span>]);<br>    close(p2[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write: system call failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (read(p2[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read: system call failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>  &#125; <br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>考察对 pipe 以及 fork 的使用。</p><p>pipe 系统调用创建一个管道，参数为长度为 2 的数组，数组下标 0 为管道读端，下标 1 为管道写端。创建后可以使用 write 和 read 进行进程间通信。</p><p>fork 系统调用创建一个和当前进程（几乎）完全相同的子进程，并且子进程有自己的内存空间，内存变量不共享，而是复制了一份，但文件描述项目表中的指针是共享的，比如这里的管道。创建的新进程同样会有 fork 的返回值，fork 函数在不同进程的返回值不同，在父进程中返回值为新创建的子进程的 pid ，而在新创建的子进程中返回0，这可以作为区分两个进程的方法。</p><p>也讲一下 read 和 write 系统调用的使用, read 接收3个参数，分别为读取文件的描述符fd、有效的内存地址用于存储读取到的内容、希望读取的长度（以字节为单位），同理 write 是将内存地址中向文件描述符指向的文件中写入，它们的返回值有三种:</p><ol><li><code>&gt; 0</code>: <strong>成功</strong>，返回读取到的字节数。</li><li><code>= 0</code>: <strong>EOF</strong>，表示文件读完了，也可能是在读管道时发现管道中已经没有数据，这是循环读取时的退出标志。</li><li><code>-1</code>: <strong>出错</strong>，比如 fd 无效，或传入了非法地址。</li></ol><p><strong>注意：</strong> write 系统调用很少返回 0，只有当 <code>write(fd, &amp;buf, 0)</code> 才可能返回 0。如果在写管道时发现读端被关闭了，那么会触发<code>SIGPIPE</code>，通常导致进程直接被杀死。如果忽略信号，则返回 -1，在 xv6 中这种情况会直接返回 -1。</p><h3 id="3-primes-moderate-hard"><a href="#3-primes-moderate-hard" class="headerlink" title="3. primes (moderate)&#x2F;(hard)"></a>3. primes (<u>moderate</u>)&#x2F;(<u>hard</u>)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> pleft[<span class="hljs-number">2</span>])</span> <br>&#123;<br>  <span class="hljs-type">int</span> pright[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int</span> prime;<br>  <span class="hljs-type">int</span> n;<br><br>  close(pleft[<span class="hljs-number">1</span>]); <span class="hljs-comment">// close write end of pleft</span><br><br>  <span class="hljs-keyword">if</span> (read(pleft[<span class="hljs-number">0</span>], &amp;prime, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) == <span class="hljs-number">0</span>) &#123;<br>    close(pleft[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;prime %d\n&quot;</span>, prime);<br>  pipe(pright);<br><br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    sieve(pright);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    close(pright[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">while</span> (read(pleft[<span class="hljs-number">0</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (n % prime != <span class="hljs-number">0</span>) &#123;<br>        write(pright[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  close(pleft[<span class="hljs-number">0</span>]);<br>  close(pright[<span class="hljs-number">1</span>]);<br>  wait(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>  <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>  pipe(p);<br><br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    sieve(p);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    close(p[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>      write(p[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    &#125;<br>    close(p[<span class="hljs-number">1</span>]);<br><br>    wait(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>用管道写一个并发的埃拉托斯特尼筛（sieve of Eratosthenes），用来筛出 35 以内的所有质数 <a href="https://swtch.com/~rsc/thread/">参考文章</a>，思想就是每个进程从左边接收一些数，输出第一个数（此数必为质数），然后将剩下的接收到的所有不能被该质数整除的数依次发送给下一个进程，直至结束。</p><p>这里用到了一个 sieve 递归函数，首先处理一下管道，输出第一个接收到的数，同时也是递归出口，如果 read 管道返回0的话就代表着所有的数已经处理完毕，直接退出。否则就使用 fork 调用创建一个新进程，当前进程把剩下的不能被质数整除的数通过管道发送给子进程，然后等待子进程结束。子进程递归调用 sieve 函数……</p><p>其中 main 函数作为入口，初始化一个管道后把所有的数全部发送给子进程，子进程开始调用 sieve 。</p><p>我认为这个的难度应该只是 moderate，并非到 hard 的程度。</p><h3 id="4-find-moderate"><a href="#4-find-moderate" class="headerlink" title="4. find (moderate)"></a>4. find (<u>moderate</u>)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">char</span>*<br><span class="hljs-title function_">getname</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[DIRSIZ+<span class="hljs-number">1</span>];<br>  <span class="hljs-type">char</span> *p;<br><br>  <span class="hljs-comment">// Find first character after last slash.</span><br>  <span class="hljs-keyword">for</span>(p=path+<span class="hljs-built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="hljs-string">&#x27;/&#x27;</span>; p--)<br>    ;<br>  p++;<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(p) &gt;= DIRSIZ)<br>    <span class="hljs-keyword">return</span> p;<br>  memmove(buf, p, <span class="hljs-built_in">strlen</span>(p));<br>  buf[<span class="hljs-built_in">strlen</span>(p)] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> buf;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span> <br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>  <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (st.type) &#123;<br>  <span class="hljs-keyword">case</span> T_FILE:<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(getname(path), target) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> T_DIR:<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(buf, path);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>      <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      memmove(p, de.name, DIRSIZ);<br>      p[DIRSIZ] = <span class="hljs-number">0</span>;<br>      find(buf, target);<br>    &#125;<br>  &#125;<br><br>  close(fd);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find &lt;path&gt; &lt;name&gt;\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>find 的实现可以参考 ls 的实现，主要难点就是处理字符串获取文件名，剩下的只要递归调用一下 find 函数就可以了。</p><h3 id="5-xargs-moderate"><a href="#5-xargs-moderate" class="headerlink" title="5. xargs (moderate)"></a>5. xargs (<u>moderate</u>)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>  <span class="hljs-type">char</span> *x_argv[MAXARG];<br>  <span class="hljs-type">int</span> x_argc = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xargs command [args...]\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>    x_argv[x_argc] = argv[i];<br>    x_argc++;<br>  &#125;<br><br>  <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">char</span> c;<br><br>  <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>      buf[n] = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>        x_argv[x_argc] = buf;<br>        x_argv[x_argc + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        exec(x_argv[<span class="hljs-number">0</span>], x_argv);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        wait(<span class="hljs-number">0</span>);<br>      &#125;<br><br>      n = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>) &#123;<br>        buf[n++] = c;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>xargs 的作用就是将管道左边命令的输出作为管道右边命令的参数，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">find . b | grep hello<br></code></pre></td></tr></table></figure><p>这条命令只会将 <code>find . b</code> 的结果作为文本传给右边的 <code>grep hello</code> 命令,即在查找到的 b 文件的路径中去寻找是否有 hello 这个单词，再看下面使用 xargs 的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">find . b | xargs grep hello<br></code></pre></td></tr></table></figure><p>这相当于将<code>find . b</code>的结果作为 <code>grep hello</code> 的参数，即在找到的 b 文件中去查找是否有 hello 这个单词。</p><hr><p>以上就是第一个 Lab: Xv6 and Unix utilities 的完成方案，最简单的 Boot xv6 我在此省略了，就是配一下环境什么的，稍微改了点东西去兼容一下我的系统，配环境网上有很多教程，我的系统也不是大家最常用的 Windows 系统，所以这里就省略了。</p><p>总体来说这个 Lab 还是十分简单，只需要阅读一下<a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6 教程</a>，并了解一些系统调用的具体使用就可以比较轻松地写出来。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>MIT courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
      <tag>Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
